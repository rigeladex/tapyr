# -*- coding: utf-8 -*-
# Copyright (C) 2020-2022 Christian Tanzer All rights reserved
# tanzer@gg32.com                                      https://www.gg32.com
# #*** <License> ************************************************************
# This module is licensed under the terms of the BSD 3-Clause License
# <https://www.gg32.com/license/bsd_3c.html>.
# #*** </License> ***********************************************************#
#
#++
# Name
#    TFL.UCD
#
# Purpose
#    Provide access to a subset of unicode characters by identifier
#
# Revision Dates
#     1-Jun-2020 (CT) Creation
#     4-Dec-2021 (CT) Add `-format` option to sub-command `by_id`
#    26-Oct-2022 (CT) Add moon symbols
#    ««revision-date»»···
#--

### https://docs.python.org/3/library/unicodedata.html
### https://www.unicode.org/reports/tr44/#General_Category_Values
### https://codepoints.net/miscellaneous_symbols_and_pictographs

from   _TFL                     import TFL

from   _TFL.Generators          import window_wise

### `_TFL._UCD_map` was generated by `create_map`
from   _TFL._UCD_map            import id_to_chr_map

import _TFL.CAO
import _TFL.Filename
import _TFL._Meta.Object

import itertools

_ignore_prefixes = \
    { "arabic_",     "^armenian_",  "balinese_",   "bamum_",      "batak_"
    , "bengali_",    "bopomofo_",   "braille_",    "buginese_",   "buhid_"
    , "canadian_",   "cham_",       "cherokee_",   "cjk_",        "coptic_"
    , "cyrillic_",   "devanagari_", "ethiopic_",   "extended_",   "georgian_"
    , "glagolitic_", "gujarati_",   "gurmukhi_",   "hangul_",     "hangzhou_"
    , "hebrew_",     "hexagram_",   "hiragana_",   "javanese_",   "kangxi_"
    , "kannada_",    "katakana_",   "kayah_",      "khmer_",      "lao_"
    , "lepcha_",     "limbu_",      "lisu_",       "malayalam_",  "mandaic_"
    , "meetei_",     "mongolian_",  "myanmar_",    "new_",        "nko_"
    , "ogham_",      "^ol_",        "oriya_",      "phags_",      "rejang_"
    , "runic_",      "russian_",    "^samaritan_", "saurashtra_", "sinhala_"
    , "sundanese_",  "syloti_",     "^syriac_",    "tagalog_",    "tagbanwa_"
    , "tai_",        "tamil_",      "telugu_",     "thai_",       "thaana_"
    , "tibetan_",    "tifinagh_",   "vai_",        "vedic_",      "yi_"
    }

class _UCD_ (TFL.Meta.Object) :
    """Provide access to unicode characters by id and by unicode name."""

    char_code_ranges = \
        ( range (0x1, 0xf001)
            ### Base plane
        , range (0x1F311, 0x1F31A)
            ### Moon symbols in Supplementary Multilingual Plane
        )

    def char_code_iter (self) :
        return itertools.chain (* self.char_code_ranges)
    # end def char_code_iter

    def create_map \
            ( self
            , ignore_categories = {"Cc", "Cs", "Co", "Cn", "Zl"}
            , ignore_prefixes   = _ignore_prefixes
            ) :
        """Create a map char-id -> char-code.

        `char-id` is a valid Python identifier derived from `unidoce.name`.
        """
        from _TFL.Ascii          import sanitized_filename
        from _TFL.formatted_repr import formatted_repr
        from _TFL.Regexp         import Regexp, re
        import unicodedata
        ignore_categories = Regexp ("|".join (sorted (ignore_categories)))
        ignore_prefixes   = Regexp ("|".join (sorted (ignore_prefixes)))
        id_to_char_map    = {}
        for i in self.char_code_iter () :
            c   = chr (i)
            cat = unicodedata.category (c)
            if ignore_categories.match (cat) :
                continue
            try :
                ucd_name    = unicodedata.name (c)
            except ValueError :
                continue
            id = sanitized_filename (ucd_name.lower ()).replace ("-", "_")
            if id.startswith ("new_moon") or not ignore_prefixes.search (id) :
                char    = (r"u%04x" if i <= 0xffff else r"U%08x") % i
                id_to_char_map   [id] = char
        result = "\n".join \
            ( ( "# -*- coding: utf-8 -*-"
              , "# Copyright (C) 2020-2022 Christian Tanzer All rights reserved"
              , "# Generated automatically, do not change manually!"
              , ""
              , "id_to_chr_map = \\"
              , formatted_repr (id_to_char_map)
                  .replace (": 'u", r": '\u")
                  .replace (": 'U", r": '\U")
              , ""
              )
            )
        return result
    # end def create_map

    def by_code (self) :
        """Generate all characters in `id_to_chr_map` sorted by code."""
        for c in sorted (id_to_chr_map.values ()) :
            yield ("%04x: %s" % (ord (c), c))
    # end def by_code

    def by_id (self, sort_key = None, format = None) :
        """Generate all characters in `id_to_chr_map` sorted by id."""
        import unicodedata
        if format is None :
            format = "%(id)-70s %(cat)-04s %(code)04x : %(char)s"
        for id, c in sorted (id_to_chr_map.items (), key = sort_key) :
            cat = unicodedata.category (c)
            yield (format % dict (id = id, cat = cat, code = ord (c), char = c))
    # end def by_id

    def get (self, name, default = None) :
        return id_to_chr_map.get (name, default)
    # end def get

    def __getattr__ (self, name) :
        return id_to_chr_map [name]
    # end def __getattr__

    def __getitem__ (self, key) :
        try :
            return id_to_chr_map [key]
        except KeyError :
            import unicodedata
            return unicodedata.lookup (key)
    # end def __getitem__

UCD = _UCD_ () # end class

def _main_create (cmd) :
    """Create map of unicode character-id to character-code."""
    map_code = UCD.create_map ()
    map_file_name = TFL.Filename  \
        (cmd.file_name, ".py", default_dir = TFL.Filename (__file__).directory)
    with open (map_file_name, "w") as file :
        file.write (map_code)
# end def _main_create

_Command_create_map = TFL.CAO.Cmd \
    ( handler       = _main_create
    , name          = "create_map"
    , opts          =
        ( "file_name:P=_UCD_map.py"
        ,
        )
    )

def _main_by_code (cmd) :
    """Print all characters in `id_to_chr_map` sorted by code."""
    cols   = cmd.columns
    chars  = UCD.by_code ()
    more   = True
    while more :
        more =  list (itertools.islice (chars, 0, cols))
        if more :
            print (* more)
# end def _main_by_code

_Command_by_code = TFL.CAO.Cmd \
    ( handler       = _main_by_code
    , name          = "by_code"
    , opts          =
        ( "columns:I=1?Print output in as many columns as specified"
        ,
        )
    )

def _main_by_id (cmd) :
    """Print all characters in `id_to_chr_map` sorted by id."""
    sk = (lambda x : x [1]) if cmd.sort_by_code else None
    for line in UCD.by_id (sk, format = cmd.format) :
        print (line)
# end def _main_by_id

_Command_by_id = TFL.CAO.Cmd \
    ( handler       = _main_by_id
    , name          = "by_id"
    , opts          =
        ( "-format:S?Format to use for output"
        , "-sort_by_code:B?Sort by character code instead of id"
        )
    )

def _main_table (cmd) :
    """Print all characters in `id_to_chr_map` as table sorted by code."""
    cols            = 16
    col_head_fmt    = "____%1.1x"
    row_head_fmt    = "%05x"
    header          = " ".join \
        (("code ", ) + tuple (col_head_fmt % i for i in range (0, cols)))
    def _gen () :
        chr_map = {ord (c) : c for c in id_to_chr_map.values ()}
        for i in UCD.char_code_iter () :
            c = chr_map.get (i, "")
            yield i, c if c.isprintable () else ""
    items   = iter (_gen ())
    lines   = 0
    s_lines = 0
    t_lines = 0
    more    = True
    while more :
        more = list (itertools.islice (items, 0, cols))
        if more :
            if any (c for i, c in more) :
                if not s_lines :
                    if t_lines :
                        print ("\v")
                    print (header)
                s_lines = 1
                code    = (row_head_fmt % more [0] [0]) [:4] + "_"
                chars   = ("  %-3s" % c for i, c in more)
                print (code, * chars)
            lines  += 1
            if lines > 15 :
                t_lines += lines
                lines    = 0
                s_lines  = 0
# end def _main_table

_Command_table = TFL.CAO.Cmd \
    ( handler       = _main_table
    , name          = "table"
    )

def _main_ucd_category (cmd) :
    """Show all characters of a specific category in `unicodedata`."""
    import unicodedata
    for i in UCD.char_code_iter () :
        c   = chr (i)
        cat = unicodedata.category (c)
        if cat.startswith (cmd.category) :
            try :
                name = unicodedata.name (c)
            except ValueError :
                name = "<%04x>" % i
            print \
                ( ( "%-30s :   %s   %s"
                  % (name, cat, c if c.isprintable () else "")
                  ).rstrip ()
                )
# end def _main_ucd_category

_Command_ucd_category = TFL.CAO.Cmd \
    ( handler       = _main_ucd_category
    , name          = "ucd_category"
    , args          =
        ( "category:S?Unicode category to show"
        ,
        )
    , max_args      = 1
    , min_args      = 1
    )

_Command = TFL.CAO.Cmd \
    ( args          =
        ( TFL.CAO.Cmd_Choice
            ( "command"
            , _Command_by_code
            , _Command_by_id
            , _Command_create_map
            , _Command_table
            , _Command_ucd_category
            )
        ,
        )
    , description   = """
The display commands (by_code, by_id, table) need to be used in conjunction
with a font containing glyphs for the various unicode characters.

One font supporting many glyphs is `DejaVuSansMono.ttf`.

For instance::

    python -m _TFL.UCD table \
      | python -m _TFL.text_to_pdf -landscape -Display -Font DejaVuSansMono.ttf -vt_limit=17 STDIN
    """
    , min_args      = 1
    )

if __name__ != "__main__" :
    TFL._Export ("UCD")
if __name__ == "__main__" :
    _Command ()
### __END__ TFL.UCD
